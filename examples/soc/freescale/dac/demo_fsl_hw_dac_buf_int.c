/*******************************************************************************
*                                 AMetal
*                       ----------------------------
*                       innovating embedded platform
*
* Copyright (c) 2001-2018 Guangzhou ZHIYUAN Electronics Co., Ltd.
* All rights reserved.
*
* Contact information:
* web site:    http://www.zlg.cn/
*******************************************************************************/

/**
 * \file
 * \brief DAC数模转换例程，通过HW接口实现
 *
 * - 实验现象：
 *   1. 配置PIOE_30为DAC模拟输出
 *   2. 用示波器采集数模转换的输出口PE30的信号输出
 *   3. 示波器显示PIOE_30的模拟输出周期大概为7秒的正弦波。
 *
 *
 * \par 源代码
 * \snippet demo_fsl_hw_dac_buf_int.c src_fsl_hw_dac_buf_int
 *
 * \internal
 * \par Modification History
 * - 1.00 16-09-26  mkr, first implementation.
 * \endinternal
 */

/**
 * \addtogroup demo_fsl_if_hw_dac_buf_int
 * \copydoc demo_fsl_hw_dac_buf_int.c
 */

 /** [src_fsl_hw_dac_buf_int] */
#include "hw/amhw_fsl_dac.h"
#include "ametal.h"
#include "am_vdebug.h"
#include "am_delay.h"
#include "am_gpio.h"
#include "am_int.h"
#include "demo_fsl_entrys.h"

#define   __BUFLEN  360

uint16_t volatile __g_sinwave_cont = 0;

static const uint16_t __g_sin_wave[__BUFLEN] = { /* 正弦波数据 */
    0x0800, 0x0823, 0x0847, 0x086B, 0x088E, 0x08B2, 0x08D6, 0x08F9,
    0x091C, 0x0940, 0x0963, 0x0986, 0x09A9, 0x09CC, 0x09EF, 0x0A11,
    0x0A34, 0x0A56, 0x0A78, 0x0A9A, 0x0ABC, 0x0ADD, 0x0AFF, 0x0B20,
    0x0B40, 0x0B61, 0x0B81, 0x0BA1, 0x0BC1, 0x0BE0, 0x0BFF, 0x0C1E,
    0x0C3D, 0x0C5B, 0x0C78, 0x0C96, 0x0CB3, 0x0CD0, 0x0CEC, 0x0D08,
    0x0D24, 0x0D3F, 0x0D5A, 0x0D74, 0x0D8E, 0x0DA7, 0x0DC0, 0x0DD9,
    0x0DF1, 0x0E09, 0x0E20, 0x0E37, 0x0E4D, 0x0E63, 0x0E78, 0x0E8D,
    0x0EA1, 0x0EB5, 0x0EC8, 0x0EDB, 0x0EED, 0x0EFE, 0x0F0F, 0x0F20,
    0x0F30, 0x0F3F, 0x0F4E, 0x0F5C, 0x0F6A, 0x0F77, 0x0F84, 0x0F8F,
    0x0F9B, 0x0FA6, 0x0FB0, 0x0FB9, 0x0FC2, 0x0FCB, 0x0FD2, 0x0FD9,
    0x0FE0, 0x0FE6, 0x0FEB, 0x0FF0, 0x0FF4, 0x0FF7, 0x0FFA, 0x0FFC,
    0x0FFE, 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFE, 0x0FFC, 0x0FFA, 0x0FF7,
    0x0FF4, 0x0FF0, 0x0FEB, 0x0FE6, 0x0FE0, 0x0FD9, 0x0FD2, 0x0FCB,
    0x0FC2, 0x0FB9, 0x0FB0, 0x0FA6, 0x0F9B, 0x0F8F, 0x0F84, 0x0F77,
    0x0F6A, 0x0F5C, 0x0F4E, 0x0F3F, 0x0F30, 0x0F20, 0x0F0F, 0x0EFE,
    0x0EED, 0x0EDB, 0x0EC8, 0x0EB5, 0x0EA1, 0x0E8D, 0x0E78, 0x0E63,
    0x0E4D, 0x0E37, 0x0E20, 0x0E09, 0x0DF1, 0x0DD9, 0x0DC0, 0x0DA7,
    0x0D8E, 0x0D74, 0x0D5A, 0x0D3F, 0x0D24, 0x0D08, 0x0CEC, 0x0CD0,
    0x0CB3, 0x0C96, 0x0C78, 0x0C5B, 0x0C3D, 0x0C1E, 0x0BFF, 0x0BE0,
    0x0BC1, 0x0BA1, 0x0B81, 0x0B61, 0x0B40, 0x0B20, 0x0AFF, 0x0ADD,
    0x0ABC, 0x0A9A, 0x0A78, 0x0A56, 0x0A34, 0x0A11, 0x09EF, 0x09CC,
    0x09A9, 0x0986, 0x0963, 0x0940, 0x091C, 0x08F9, 0x08D6, 0x08B2,
    0x088E, 0x086B, 0x0847, 0x0823, 0x0800, 0x07DC, 0x07B8, 0x0794,
    0x0771, 0x074D, 0x0729, 0x0706, 0x06E3, 0x06BF, 0x069C, 0x0679,
    0x0656, 0x0633, 0x0610, 0x05EE, 0x05CB, 0x05A9, 0x0587, 0x0565,
    0x0543, 0x0522, 0x0500, 0x04DF, 0x04BF, 0x049E, 0x047E, 0x045E,
    0x043E, 0x041F, 0x0400, 0x03E1, 0x03C2, 0x03A4, 0x0387, 0x0369,
    0x034C, 0x032F, 0x0313, 0x02F7, 0x02DB, 0x02C0, 0x02A5, 0x028B,
    0x0271, 0x0258, 0x023F, 0x0226, 0x020E, 0x01F6, 0x01DF, 0x01C8,
    0x01B2, 0x019C, 0x0187, 0x0172, 0x015E, 0x014A, 0x0137, 0x0124,
    0x0112, 0x0101, 0x00F0, 0x00DF, 0x00CF, 0x00C0, 0x00B1, 0x00A3,
    0x0095, 0x0088, 0x007B, 0x0070, 0x0064, 0x0059, 0x004F, 0x0046,
    0x003D, 0x0034, 0x002D, 0x0026, 0x001F, 0x0019, 0x0014, 0x000F,
    0x000B, 0x0008, 0x0005, 0x0003, 0x0001, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0003, 0x0005, 0x0008, 0x000B, 0x000F, 0x0014, 0x0019,
    0x001F, 0x0026, 0x002D, 0x0034, 0x003D, 0x0046, 0x004F, 0x0059,
    0x0064, 0x0070, 0x007B, 0x0088, 0x0095, 0x00A3, 0x00B1, 0x00C0,
    0x00CF, 0x00DF, 0x00F0, 0x0101, 0x0112, 0x0124, 0x0137, 0x014A,
    0x015E, 0x0172, 0x0187, 0x019C, 0x01B2, 0x01C8, 0x01DF, 0x01F6,
    0x020E, 0x0226, 0x023F, 0x0258, 0x0271, 0x028B, 0x02A5, 0x02C0,
    0x02DB, 0x02F7, 0x0313, 0x032F, 0x034C, 0x0369, 0x0387, 0x03A4,
    0x03C2, 0x03E1, 0x0400, 0x041F, 0x043E, 0x045E, 0x047E, 0x049E,
    0x04BF, 0x04DF, 0x0500, 0x0522, 0x0543, 0x0565, 0x0587, 0x05A9,
    0x05CB, 0x05EE, 0x0610, 0x0633, 0x0656, 0x0679, 0x069C, 0x06BF,
    0x06E3, 0x0706, 0x0729, 0x074D, 0x0771, 0x0794, 0x07B8, 0x07DC,
};

/**
 * \brief DAC 中断服务函数
 */
static void __fsl_dac_int (void *p_arg)
{
    amhw_fsl_dac_t *p_hw_dac = (amhw_fsl_dac_t *)p_arg;

    /* 读取底指针中断清除*/
    if (amhw_fsl_dac_bufint_flag_get(p_hw_dac,
        AMHW_FSL_DAC_BUF_FLAG_START)) {
       amhw_fsl_dac_bufint_flag_clr(p_hw_dac,
                                     AMHW_FSL_DAC_BUF_FLAG_START);

       amhw_fsl_dac_buf_val_set(p_hw_dac,
                                 0,
                                 2,
                                 (uint16_t *)(__g_sin_wave + __g_sinwave_cont));
    }

    __g_sinwave_cont += 2;

    if(__g_sinwave_cont >= __BUFLEN){
        __g_sinwave_cont = 0;
    }

}

/**
 * \brief DAC 使用缓冲区中断输出正弦波信号，HW层实现
 * \return 无
 */
void demo_fsl_hw_dac_buf_int_entry (amhw_fsl_dac_t *p_hw_dac,
                                    int             inum)
{
    /**
     * \brief DAC 缓存区功能配置结构体定义
     */
    amhw_fsl_dac_buffer_config_t dac_buf_cfg={
        AM_TRUE,                         /* 使能BUF功能                   */
        AMHW_FSL_DAC_TRG_SOFT,           /* 软件触发                           */
        AM_TRUE,                         /* 缓冲读取底指针中断使能 */
        AM_FALSE,                        /* 缓冲读取顶指针中断禁能 */
        AM_FALSE,                        /* 禁止DMA功能                    */
        AMHW_FSL_DAC_BUFMODE_NORMAL,     /* 缓存区模式为正常模式      */
        AM_TRUE,                         /* 缓存区上限使能                 */
    };

    /* DAC数据缓存区初始化 */
    amhw_fsl_dac_dat_buf_init(p_hw_dac, &dac_buf_cfg);

    extern int am_int_connect (int inum, am_pfnvoid_t pfn_isr, void *p_arg);
    extern int am_int_enable (int inum);

    /* DAC中断链接函数 */
    am_int_connect(inum, __fsl_dac_int, p_hw_dac);
    am_int_enable(inum);

    /* 使能DAC功能 */
    amhw_fsl_dac_enable(p_hw_dac);

    /* 设置DAC缓存区的值 */
    uint32_t key = am_int_cpu_lock();
    amhw_fsl_dac_buf_val_set(p_hw_dac,
                             0,
                             2,
                             (uint16_t*)(__g_sin_wave + __g_sinwave_cont));

    __g_sinwave_cont += 2;
    am_int_cpu_unlock(key);

    /* 软件触发DAC转换功能 */
    amhw_fsl_dac_soft_trg_enable(p_hw_dac);

    while (1) {
        amhw_fsl_dac_soft_trg_enable(p_hw_dac);
        am_mdelay(20);
    }
}

/** [src_fsl_hw_dac_buf_int] */

/* end of file */
